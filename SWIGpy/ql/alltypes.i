#ifndef ql_all_types_i
#define ql_all_types_i

%{
namespace QuantLib { namespace ext {} }
namespace ext = QuantLib::ext;
%}

#define SWIG_SHARED_PTR_NAMESPACE ext

%{
using QuantLib::ASX;
using QuantLib::AUCPI;
using QuantLib::Actual365Fixed;
using QuantLib::AdaptiveRungeKutta;
using QuantLib::AdditiveEQPBinomialTree;
using QuantLib::AmericanExercise;
using QuantLib::AmortizingFixedRateBond;
using QuantLib::AmortizingFloatingRateBond;
using QuantLib::AmortizingPayment;
using QuantLib::AnalyticBSMHullWhiteEngine;
using QuantLib::AnalyticBarrierEngine;
using QuantLib::AnalyticBinaryBarrierEngine;
using QuantLib::AnalyticCEVEngine;
using QuantLib::AnalyticCapFloorEngine;
using QuantLib::AnalyticContinuousFixedLookbackEngine;
using QuantLib::AnalyticContinuousFloatingLookbackEngine;
using QuantLib::AnalyticContinuousGeometricAveragePriceAsianEngine;
using QuantLib::AnalyticContinuousGeometricAveragePriceAsianHestonEngine;
using QuantLib::AnalyticContinuousPartialFixedLookbackEngine;
using QuantLib::AnalyticContinuousPartialFloatingLookbackEngine;
using QuantLib::AnalyticDigitalAmericanEngine;
using QuantLib::AnalyticDigitalAmericanKOEngine;
using QuantLib::AnalyticDiscreteGeometricAveragePriceAsianEngine;
using QuantLib::AnalyticDiscreteGeometricAveragePriceAsianHestonEngine;
using QuantLib::AnalyticDiscreteGeometricAverageStrikeAsianEngine;
using QuantLib::AnalyticDividendEuropeanEngine;
using QuantLib::AnalyticDoubleBarrierBinaryEngine;
using QuantLib::AnalyticDoubleBarrierEngine;
using QuantLib::AnalyticEuropeanEngine;
using QuantLib::AnalyticGJRGARCHEngine;
using QuantLib::AnalyticHaganPricer;
using QuantLib::AnalyticHestonEngine;
using QuantLib::AnalyticHestonForwardEuropeanEngine;
using QuantLib::AnalyticPTDHestonEngine;
using QuantLib::AndreasenHugeLocalVolAdapter;
using QuantLib::AndreasenHugeVolatilityAdapter;
using QuantLib::AndreasenHugeVolatilityInterpl;
using QuantLib::Annual;
using QuantLib::April;
using QuantLib::Array;
using QuantLib::AssetOrNothingPayoff;
using QuantLib::AssetSwap;
using QuantLib::August;
using QuantLib::Average;
using QuantLib::AverageBasketPayoff;
using QuantLib::BFGS;
using QuantLib::BSMRNDCalculator;
using QuantLib::BachelierCapFloorEngine;
using QuantLib::BachelierSwaptionEngine;
using QuantLib::BackwardFlat;
using QuantLib::BaroneAdesiWhaleyApproximationEngine;
using QuantLib::Barrier;
using QuantLib::BarrierOption;
using QuantLib::BasketGeneratingEngine;
using QuantLib::BasketOption;
using QuantLib::BasketPayoff;
using QuantLib::BatesEngine;
using QuantLib::BatesModel;
using QuantLib::BatesProcess;
using QuantLib::BermudanExercise;
using QuantLib::BiCGstab;
using QuantLib::Bicubic;
using QuantLib::BigInteger;
using QuantLib::BigNatural;
using QuantLib::Bimonthly;
using QuantLib::BinomialBarrierEngine;
using QuantLib::BinomialConvertibleEngine;
using QuantLib::BinomialDistribution;
using QuantLib::BinomialDoubleBarrierEngine;
using QuantLib::BinomialVanillaEngine;
using QuantLib::Bisection;
using QuantLib::BivariateCumulativeNormalDistribution;
using QuantLib::BivariateCumulativeNormalDistributionDr78;
using QuantLib::BivariateCumulativeNormalDistributionWe04DP;
using QuantLib::Biweekly;
using QuantLib::BjerksundStenslandApproximationEngine;
using QuantLib::BlackCalculator;
using QuantLib::BlackCalibrationHelper;
using QuantLib::BlackCallableFixedRateBondEngine;
using QuantLib::BlackCapFloorEngine;
using QuantLib::BlackCdsOptionEngine;
using QuantLib::BlackConstantVol;
using QuantLib::BlackDeltaCalculator;
using QuantLib::BlackIborCouponPricer;
using QuantLib::BlackKarasinski;
using QuantLib::BlackProcess;
using QuantLib::BlackScholesMertonProcess;
using QuantLib::BlackScholesProcess;
using QuantLib::BlackSwaptionEngine;
using QuantLib::BlackVarianceCurve;
using QuantLib::BlackVarianceSurface;
using QuantLib::BlackVolTermStructure;
using QuantLib::Bond;
using QuantLib::BondFunctions;
using QuantLib::BondHelper;
using QuantLib::BootstrapHelper;
using QuantLib::BoundaryCondition;
using QuantLib::BoundaryConstraint;
using QuantLib::BoxMullerGaussianRng;
using QuantLib::Brent;
using QuantLib::BrownianBridge;
using QuantLib::BrownianGenerator;
using QuantLib::BrownianGeneratorFactory;
using QuantLib::BusinessDayConvention;
using QuantLib::CEVRNDCalculator;
using QuantLib::CLGaussianRng;
using QuantLib::COSHestonEngine;
using QuantLib::CPI;
using QuantLib::CPIBond;
using QuantLib::CPICoupon;
using QuantLib::CPISwap;
using QuantLib::Calendar;
using QuantLib::CalibratedModel;
using QuantLib::CalibrationHelper;
using QuantLib::Callability;
using QuantLib::CallabilitySchedule;
using QuantLib::CallableBond;
using QuantLib::CallableFixedRateBond;
using QuantLib::CallableZeroCouponBond;
using QuantLib::Cap;
using QuantLib::CapFloor;
using QuantLib::CapFloorTermVolCurve;
using QuantLib::CapFloorTermVolSurface;
using QuantLib::CapFloorTermVolatilityStructure;
using QuantLib::CapHelper;
using QuantLib::CappedFlooredCmsCoupon;
using QuantLib::CappedFlooredCmsSpreadCoupon;
using QuantLib::CappedFlooredCoupon;
using QuantLib::CappedFlooredIborCoupon;
using QuantLib::CashFlow;
using QuantLib::CashFlows;
using QuantLib::CashOrNothingPayoff;
using QuantLib::CdsOption;
using QuantLib::CeilingTruncation;
using QuantLib::Claim;
using QuantLib::ClosestRounding;
using QuantLib::CmsCoupon;
using QuantLib::CmsCouponPricer;
using QuantLib::CmsMarket;
using QuantLib::CmsMarketCalibration;
using QuantLib::CmsRateBond;
using QuantLib::CmsSpreadCoupon;
using QuantLib::CmsSpreadCouponPricer;
using QuantLib::Collar;
using QuantLib::CompositeConstraint;
using QuantLib::CompositeInstrument;
using QuantLib::CompositeQuote;
using QuantLib::CompositeZeroYieldStructure;
using QuantLib::Compounded;
using QuantLib::CompoundedThenSimple;
using QuantLib::Compounding;
using QuantLib::Concentrating1dMesher;
using QuantLib::ConjugateGradient;
using QuantLib::ConstantEstimator;
using QuantLib::ConstantOptionletVolatility;
using QuantLib::ConstantParameter;
using QuantLib::ConstantSwaptionVolatility;
using QuantLib::ConstantYoYOptionletVolatility;
using QuantLib::Constraint;
using QuantLib::Continuous;
using QuantLib::ContinuousArithmeticAsianLevyEngine;
using QuantLib::ContinuousAveragingAsianOption;
using QuantLib::ContinuousFixedLookbackOption;
using QuantLib::ContinuousFloatingLookbackOption;
using QuantLib::ContinuousPartialFixedLookbackOption;
using QuantLib::ContinuousPartialFloatingLookbackOption;
using QuantLib::ConvertibleFixedCouponBond;
using QuantLib::ConvertibleFloatingRateBond;
using QuantLib::ConvertibleZeroCouponBond;
using QuantLib::ConvexMonotone;
using QuantLib::CostFunction;
using QuantLib::Coupon;
using QuantLib::CoxIngersollRoss;
using QuantLib::CoxRossRubinstein;
using QuantLib::CraigSneydScheme;
using QuantLib::CrankNicolson;
using QuantLib::CrankNicolsonScheme;
using QuantLib::CreditDefaultSwap;
using QuantLib::Cubic;
using QuantLib::CubicBSplinesFitting;
using QuantLib::CumulativeBinomialDistribution;
using QuantLib::CumulativeChiSquareDistribution;
using QuantLib::CumulativeGammaDistribution;
using QuantLib::CumulativeNormalDistribution;
using QuantLib::CumulativePoissonDistribution;
using QuantLib::CumulativeStudentDistribution;
using QuantLib::Currency;
using QuantLib::CustomRegion;
using QuantLib::DMinus;
using QuantLib::DPlus;
using QuantLib::DPlusDMinus;
using QuantLib::DZero;
using QuantLib::Daily;
using QuantLib::DailyTenorLibor;
using QuantLib::Date;
using QuantLib::DateGeneration;
using QuantLib::DateParser;
using QuantLib::DatedOISRateHelper;
using QuantLib::Day;
using QuantLib::DayCounter;
using QuantLib::Days;
using QuantLib::December;
using QuantLib::Decimal;
using QuantLib::Default;
using QuantLib::DefaultDensity;
using QuantLib::DefaultProbabilityHelper;
using QuantLib::DefaultProbabilityTermStructure;
using QuantLib::DeltaVolQuote;
using QuantLib::DepositRateHelper;
using QuantLib::DerivedQuote;
using QuantLib::DifferentialEvolution;
using QuantLib::DirichletBC;
using QuantLib::Discount;
using QuantLib::DiscountFactor;
using QuantLib::DiscountingBondEngine;
using QuantLib::DiscountingSwapEngine;
using QuantLib::DiscreteAveragingAsianOption;
using QuantLib::DiscretizedDermanKaniBarrierOption;
using QuantLib::DiscretizedDermanKaniDoubleBarrierOption;
using QuantLib::Disposable;
using QuantLib::Dividend;
using QuantLib::DividendBarrierOption;
using QuantLib::DividendVanillaOption;
using QuantLib::DoubleBarrier;
using QuantLib::DoubleBarrierOption;
using QuantLib::DouglasScheme;
using QuantLib::DownRounding;
using QuantLib::Duration;
using QuantLib::EndCriteria;
using QuantLib::Error;
using QuantLib::EuropeanExercise;
using QuantLib::EuropeanOption;
using QuantLib::EverestOption;
using QuantLib::EveryFourthMonth;
using QuantLib::EveryFourthWeek;
using QuantLib::ExchangeRate;
using QuantLib::ExchangeRateManager;
using QuantLib::Exercise;
using QuantLib::ExplicitEulerScheme;
using QuantLib::ExponentialFittingHestonEngine;
using QuantLib::ExponentialJump1dMesher;
using QuantLib::ExponentialSplinesFitting;
using QuantLib::ExtOUWithJumpsProcess;
using QuantLib::ExtendedCoxIngersollRoss;
using QuantLib::ExtendedOrnsteinUhlenbeckProcess;
using QuantLib::FDAmericanEngine;
using QuantLib::FDBermudanEngine;
using QuantLib::FDDividendAmericanEngine;
using QuantLib::FDDividendEuropeanEngine;
using QuantLib::FDEuropeanEngine;
using QuantLib::FDShoutEngine;
using QuantLib::FFTVarianceGammaEngine;
using QuantLib::FaceValueAccrualClaim;
using QuantLib::FaceValueClaim;
using QuantLib::FalsePosition;
using QuantLib::Fd2dBlackScholesVanillaEngine;
using QuantLib::FdBatesVanillaEngine;
using QuantLib::FdBlackScholesAsianEngine;
using QuantLib::FdBlackScholesBarrierEngine;
using QuantLib::FdBlackScholesRebateEngine;
using QuantLib::FdBlackScholesVanillaEngine;
using QuantLib::FdCEVVanillaEngine;
using QuantLib::FdG2SwaptionEngine;
using QuantLib::FdHestonBarrierEngine;
using QuantLib::FdHestonDoubleBarrierEngine;
using QuantLib::FdHestonRebateEngine;
using QuantLib::FdHestonVanillaEngine;
using QuantLib::FdHullWhiteSwaptionEngine;
using QuantLib::FdOrnsteinUhlenbeckVanillaEngine;
using QuantLib::FdSabrVanillaEngine;
using QuantLib::FdSimpleBSSwingEngine;
using QuantLib::FdSimpleExtOUJumpSwingEngine;
using QuantLib::Fdm1DimSolver;
using QuantLib::Fdm1dMesher;
using QuantLib::Fdm2DimSolver;
using QuantLib::Fdm2dBlackScholesOp;
using QuantLib::Fdm2dBlackScholesSolver;
using QuantLib::Fdm3DimSolver;
using QuantLib::FdmAffineModelSwapInnerValue;
using QuantLib::FdmAmericanStepCondition;
using QuantLib::FdmArithmeticAverageCondition;
using QuantLib::FdmBackwardSolver;
using QuantLib::FdmBatesOp;
using QuantLib::FdmBermudanStepCondition;
using QuantLib::FdmBlackScholesFwdOp;
using QuantLib::FdmBlackScholesMesher;
using QuantLib::FdmBlackScholesOp;
using QuantLib::FdmCEV1dMesher;
using QuantLib::FdmCEVOp;
using QuantLib::FdmCellAveragingInnerValue;
using QuantLib::FdmDirichletBoundary;
using QuantLib::FdmDiscountDirichletBoundary;
using QuantLib::FdmDividendHandler;
using QuantLib::FdmDupire1dOp;
using QuantLib::FdmG2Op;
using QuantLib::FdmG2Solver;
using QuantLib::FdmHestonFwdOp;
using QuantLib::FdmHestonGreensFct;
using QuantLib::FdmHestonHullWhiteOp;
using QuantLib::FdmHestonHullWhiteSolver;
using QuantLib::FdmHestonLocalVolatilityVarianceMesher;
using QuantLib::FdmHestonOp;
using QuantLib::FdmHestonSolver;
using QuantLib::FdmHestonVarianceMesher;
using QuantLib::FdmHullWhiteOp;
using QuantLib::FdmHullWhiteSolver;
using QuantLib::FdmIndicesOnBoundary;
using QuantLib::FdmInnerValueCalculator;
using QuantLib::FdmLinearOp;
using QuantLib::FdmLinearOpComposite;
using QuantLib::FdmLinearOpIterator;
using QuantLib::FdmLinearOpLayout;
using QuantLib::FdmLocalVolFwdOp;
using QuantLib::FdmLogBasketInnerValue;
using QuantLib::FdmLogInnerValue;
using QuantLib::FdmMesher;
using QuantLib::FdmMesherComposite;
using QuantLib::FdmNdimSolver;
using QuantLib::FdmOrnsteinUhlenbeckOp;
using QuantLib::FdmQuantoHelper;
using QuantLib::FdmSabrOp;
using QuantLib::FdmSchemeDesc;
using QuantLib::FdmSimpleProcess1dMesher;
using QuantLib::FdmSimpleStorageCondition;
using QuantLib::FdmSimpleSwingCondition;
using QuantLib::FdmSnapshotCondition;
using QuantLib::FdmSolverDesc;
using QuantLib::FdmSquareRootFwdOp;
using QuantLib::FdmStepConditionComposite;
using QuantLib::FdmTimeDepDirichletBoundary;
using QuantLib::FdmZabrOp;
using QuantLib::FdmZeroInnerValue;
using QuantLib::February;
using QuantLib::FirstDerivativeOp;
using QuantLib::FittedBondDiscountCurve;
using QuantLib::FixedDividend;
using QuantLib::FixedRateBond;
using QuantLib::FixedRateBondForward;
using QuantLib::FixedRateBondHelper;
using QuantLib::FixedRateCoupon;
using QuantLib::FlatForward;
using QuantLib::FlatHazardRate;
using QuantLib::FlatSmileSection;
using QuantLib::FloatFloatSwap;
using QuantLib::FloatFloatSwaption;
using QuantLib::FloatingRateBond;
using QuantLib::FloatingRateCoupon;
using QuantLib::FloatingRateCouponPricer;
using QuantLib::FloatingTypePayoff;
using QuantLib::Floor;
using QuantLib::FloorTruncation;
using QuantLib::Following;
using QuantLib::Forward;
using QuantLib::ForwardFlat;
using QuantLib::ForwardRate;
using QuantLib::ForwardRateAgreement;
using QuantLib::ForwardSpreadedTermStructure;
using QuantLib::ForwardVanillaEngine;
using QuantLib::ForwardVanillaOption;
using QuantLib::FraRateHelper;
using QuantLib::FractionalDividend;
using QuantLib::Frequency;
using QuantLib::Friday;
using QuantLib::Futures;
using QuantLib::FuturesRateHelper;
using QuantLib::FxSwapRateHelper;
using QuantLib::G2;
using QuantLib::G2ForwardProcess;
using QuantLib::G2Process;
using QuantLib::G2SwaptionEngine;
using QuantLib::GBSMRNDCalculator;
using QuantLib::GFunctionFactory;
using QuantLib::GJRGARCHModel;
using QuantLib::GJRGARCHProcess;
using QuantLib::GMRES;
using QuantLib::GammaFunction;
using QuantLib::GapPayoff;
using QuantLib::GarmanKlassSigma1;
using QuantLib::GarmanKlassSigma3;
using QuantLib::GarmanKlassSigma4;
using QuantLib::GarmanKlassSigma5;
using QuantLib::GarmanKlassSigma6;
using QuantLib::GarmanKohlagenProcess;
using QuantLib::GaussChebyshev2ndIntegration;
using QuantLib::GaussChebyshevIntegration;
using QuantLib::GaussGegenbauerIntegration;
using QuantLib::GaussHermiteIntegration;
using QuantLib::GaussHyperbolicIntegration;
using QuantLib::GaussJacobiIntegration;
using QuantLib::GaussKronrodAdaptive;
using QuantLib::GaussKronrodNonAdaptive;
using QuantLib::GaussLaguerreIntegration;
using QuantLib::GaussLegendreIntegration;
using QuantLib::GaussLobattoIntegral;
using QuantLib::Gaussian1dFloatFloatSwaptionEngine;
using QuantLib::Gaussian1dJamshidianSwaptionEngine;
using QuantLib::Gaussian1dModel;
using QuantLib::Gaussian1dNonstandardSwaptionEngine;
using QuantLib::Gaussian1dSwaptionEngine;
using QuantLib::GaussianSimulatedAnnealing;
using QuantLib::GeneralizedBlackScholesProcess;
using QuantLib::GenericSequenceStatistics;
using QuantLib::GeometricBrownianMotionProcess;
using QuantLib::Glued1dMesher;
using QuantLib::Gsr;
using QuantLib::GsrProcess;
using QuantLib::HalfMonthModifiedFollowing;
using QuantLib::HaltonRsg;
using QuantLib::Handle;
using QuantLib::HazardRate;
using QuantLib::HestonBlackVolSurface;
using QuantLib::HestonModel;
using QuantLib::HestonModelHelper;
using QuantLib::HestonProcess;
using QuantLib::HestonRNDCalculator;
using QuantLib::HestonSLVFDMModel;
using QuantLib::HestonSLVFokkerPlanckFdmParams;
using QuantLib::HestonSLVMCModel;
using QuantLib::HestonSLVProcess;
using QuantLib::HimalayaOption;
//using QuantLib::Hour;
//using QuantLib::Hours;
using QuantLib::HullWhite;
using QuantLib::HullWhiteForwardProcess;
using QuantLib::HullWhiteProcess;
using QuantLib::HundsdorferScheme;
using QuantLib::IMM;
using QuantLib::IborCoupon;
using QuantLib::IborCouponPricer;
using QuantLib::IborIndex;
using QuantLib::ImplicitEulerScheme;
using QuantLib::ImpliedTermStructure;
using QuantLib::IncrementalStatistics;
using QuantLib::Index;
using QuantLib::IndexManager;
using QuantLib::IndexedCashFlow;
using QuantLib::InflationCoupon;
using QuantLib::InflationIndex;
using QuantLib::InflationTermStructure;
using QuantLib::Instrument;
using QuantLib::Integer;
using QuantLib::IntegralCdsEngine;
using QuantLib::IntegralEngine;
using QuantLib::InterestRate;
using QuantLib::InterestRateIndex;
using QuantLib::InterpolatedDefaultDensityCurve;
using QuantLib::InterpolatedDiscountCurve;
using QuantLib::InterpolatedForwardCurve;
using QuantLib::InterpolatedHazardRateCurve;
using QuantLib::InterpolatedPiecewiseZeroSpreadedTermStructure;
using QuantLib::InterpolatedSmileSection;
using QuantLib::InterpolatedSurvivalProbabilityCurve;
using QuantLib::InterpolatedYoYCapFloorTermPriceSurface;
using QuantLib::InterpolatedYoYInflationCurve;
using QuantLib::InterpolatedYoYOptionletStripper;
using QuantLib::InterpolatedYoYOptionletVolatilityCurve;
using QuantLib::InterpolatedZeroCurve;
using QuantLib::InterpolatedZeroInflationCurve;
using QuantLib::IntervalPrice;
using QuantLib::InverseCumulativeNormal;
using QuantLib::InverseCumulativePoisson;
using QuantLib::InverseCumulativeRng;
using QuantLib::InverseCumulativeRsg;
using QuantLib::InverseCumulativeStudent;
using QuantLib::InverseNonCentralCumulativeChiSquareDistribution;
using QuantLib::IsdaCdsEngine;
using QuantLib::JamshidianSwaptionEngine;
using QuantLib::January;
using QuantLib::JarrowRudd;
using QuantLib::JoinBusinessDays;
using QuantLib::JoinHolidays;
using QuantLib::JointCalendarRule;
using QuantLib::Joshi4;
using QuantLib::JuQuadraticApproximationEngine;
using QuantLib::July;
using QuantLib::June;
using QuantLib::KInterpolatedYoYOptionletVolatilitySurface;
using QuantLib::KahaleSmileSection;
using QuantLib::KerkhofSeasonality;
using QuantLib::KirkEngine;
using QuantLib::KirkSpreadOptionEngine;
using QuantLib::KlugeExtOUProcess;
using QuantLib::KnuthUniformRng;
using QuantLib::LecuyerUniformRng;
using QuantLib::Leg;
using QuantLib::LeisenReimer;
using QuantLib::LevenbergMarquardt;
using QuantLib::Libor;
using QuantLib::Linear;
using QuantLib::LinearTsrPricer;
using QuantLib::LocalConstantVol;
using QuantLib::LocalVolRNDCalculator;
using QuantLib::LocalVolSurface;
using QuantLib::LocalVolTermStructure;
using QuantLib::LogLinear;
using QuantLib::LogNormalSimulatedAnnealing;
using QuantLib::LognormalCmsSpreadPricer;
using QuantLib::LowDiscrepancy;
using QuantLib::LsmBasisSystem;
using QuantLib::MCAmericanBasketEngine;
using QuantLib::MCAmericanEngine;
using QuantLib::MCBarrierEngine;
using QuantLib::MCDiscreteArithmeticAPEngine;
using QuantLib::MCDiscreteArithmeticAPHestonEngine;
using QuantLib::MCDiscreteArithmeticASEngine;
using QuantLib::MCDiscreteGeometricAPEngine;
using QuantLib::MCDiscreteGeometricAPHestonEngine;
using QuantLib::MCEuropeanBasketEngine;
using QuantLib::MCEuropeanEngine;
using QuantLib::MCEuropeanGJRGARCHEngine;
using QuantLib::MCEuropeanHestonEngine;
using QuantLib::MCEverestEngine;
using QuantLib::MCForwardEuropeanBSEngine;
using QuantLib::MCForwardEuropeanHestonEngine;
using QuantLib::MCHimalayaEngine;
using QuantLib::MTBrownianGenerator;
using QuantLib::MTBrownianGeneratorFactory;
using QuantLib::MakeOIS;
using QuantLib::MakeSchedule;
using QuantLib::MakeVanillaSwap;
using QuantLib::March;
using QuantLib::MarkovFunctional;
using QuantLib::Matrix;
using QuantLib::MaxBasketPayoff;
using QuantLib::May;
using QuantLib::MersenneTwisterUniformRng;
using QuantLib::Merton76Process;
using QuantLib::MethodOfLinesScheme;
//using QuantLib::Microsecond;
//using QuantLib::Microseconds;
using QuantLib::MidPoint;
using QuantLib::MidPointCdsEngine;
//using QuantLib::Millisecond;
//using QuantLib::Milliseconds;
using QuantLib::MinBasketPayoff;
//using QuantLib::Minute;
//using QuantLib::Minutes;
using QuantLib::MirrorGaussianSimulatedAnnealing;
using QuantLib::ModifiedCraigSneydScheme;
using QuantLib::ModifiedFollowing;
using QuantLib::ModifiedPreceding;
using QuantLib::Monday;
using QuantLib::Money;
using QuantLib::Month;
using QuantLib::Monthly;
using QuantLib::Months;
using QuantLib::MoroInverseCumulativeNormal;
using QuantLib::MultiAssetOption;
using QuantLib::MultiPath;
using QuantLib::MultiPathGenerator;
using QuantLib::MultiplicativePriceSeasonality;
using QuantLib::Natural;
using QuantLib::NelsonSiegelFitting;
using QuantLib::NeumannBC;
using QuantLib::Newton;
using QuantLib::NewtonSafe;
using QuantLib::NinePointLinearOp;
using QuantLib::NoArbSabrInterpolatedSmileSection;
using QuantLib::NoArbSabrSmileSection;
using QuantLib::NoConstraint;
using QuantLib::NoExceptLocalVolSurface;
using QuantLib::NoFrequency;
using QuantLib::NonCentralCumulativeChiSquareDistribution;
using QuantLib::NonhomogeneousBoundaryConstraint;
using QuantLib::NonstandardSwap;
using QuantLib::NonstandardSwaption;
using QuantLib::Normal;
using QuantLib::NormalDistribution;
using QuantLib::November;
using QuantLib::NthOrderDerivativeOp;
using QuantLib::Null;
using QuantLib::NullCalendar;
using QuantLib::NullParameter;
using QuantLib::NumericHaganPricer;
using QuantLib::OISRateHelper;
using QuantLib::Observable;
using QuantLib::Observer;
using QuantLib::October;
using QuantLib::Once;
using QuantLib::OneAssetOption;
using QuantLib::OneFactorAffineModel;
using QuantLib::OptimizationMethod;
using QuantLib::Option;
using QuantLib::OptionletStripper1;
using QuantLib::OptionletVolatilityStructure;
using QuantLib::OrnsteinUhlenbeckProcess;
using QuantLib::OtherFrequency;
using QuantLib::OvernightIndex;
using QuantLib::OvernightIndexFuture;
using QuantLib::OvernightIndexFutureRateHelper;
using QuantLib::OvernightIndexedCoupon;
using QuantLib::OvernightIndexedSwap;
using QuantLib::OvernightIndexedSwapIndex;
using QuantLib::Parameter;
using QuantLib::ParkinsonSigma;
using QuantLib::Path;
using QuantLib::PathGenerator;
using QuantLib::Payoff;
using QuantLib::PercentageStrikePayoff;
using QuantLib::Period;
using QuantLib::PeriodParser;
using QuantLib::PiecewiseConstantParameter;
using QuantLib::PiecewiseDefaultCurve;
using QuantLib::PiecewiseTimeDependentHestonModel;
using QuantLib::PiecewiseYieldCurve;
using QuantLib::PiecewiseYoYInflationCurve;
using QuantLib::PiecewiseZeroInflationCurve;
using QuantLib::Pillar;
using QuantLib::PlainVanillaPayoff;
using QuantLib::PoissonDistribution;
using QuantLib::Position;
using QuantLib::PositiveConstraint;
using QuantLib::Preceding;
using QuantLib::Predefined1dMesher;
using QuantLib::PricingEngine;
using QuantLib::Probability;
using QuantLib::ProbabilityBoltzmannDownhill;
using QuantLib::Problem;
using QuantLib::Protection;
using QuantLib::PseudoRandom;
using QuantLib::QuantoDoubleBarrierOption;
using QuantLib::QuantoEngine;
using QuantLib::QuantoForwardVanillaOption;
using QuantLib::QuantoVanillaOption;
using QuantLib::Quarterly;
using QuantLib::Quote;
using QuantLib::RandomSequenceGenerator;
using QuantLib::Rate;
using QuantLib::RateHelper;
using QuantLib::Real;
using QuantLib::ReannealingTrivial;
using QuantLib::RebatedExercise;
using QuantLib::Redemption;
using QuantLib::Region;
using QuantLib::RelinkableHandle;
using QuantLib::RichardsonExtrapolation;
using QuantLib::Ridder;
using QuantLib::RiskNeutralDensityCalculator;
using QuantLib::RiskStatistics;
using QuantLib::Rounding;
using QuantLib::SVD;
using QuantLib::SabrSmileSection;
using QuantLib::SalvagingAlgorithm;
using QuantLib::Sample;
using QuantLib::SampledCurve;
using QuantLib::SamplerGaussian;
using QuantLib::SamplerLogNormal;
using QuantLib::SamplerMirrorGaussian;
using QuantLib::Saturday;
using QuantLib::Schedule;
using QuantLib::Seasonality;
using QuantLib::Secant;
//using QuantLib::Second;
using QuantLib::SecondDerivativeOp;
using QuantLib::SecondOrderMixedDerivativeOp;
//using QuantLib::Seconds;
using QuantLib::SegmentIntegral;
using QuantLib::Semiannual;
using QuantLib::September;
using QuantLib::Settings;
using QuantLib::Settlement;
using QuantLib::ShiftedLognormal;
using QuantLib::ShortRateModel;
using QuantLib::Simple;
using QuantLib::SimpleCashFlow;
using QuantLib::SimpleLocalEstimator;
using QuantLib::SimplePolynomialFitting;
using QuantLib::SimpleQuote;
using QuantLib::SimpleThenCompounded;
using QuantLib::SimpleZeroYield;
using QuantLib::Simplex;
using QuantLib::SimpsonIntegral;
using QuantLib::Size;
using QuantLib::SmileSection;
using QuantLib::SobolBrownianBridgeRsg;
using QuantLib::SobolBrownianGenerator;
using QuantLib::SobolBrownianGeneratorFactory;
using QuantLib::SobolRsg;
using QuantLib::SofrFutureRateHelper;
using QuantLib::SoftCallability;
using QuantLib::Spread;
using QuantLib::SpreadBasketPayoff;
using QuantLib::SpreadCdsHelper;
using QuantLib::SpreadOption;
using QuantLib::SquareRootProcessRNDCalculator;
using QuantLib::Statistics;
using QuantLib::SteepestDescent;
using QuantLib::StepCondition;
using QuantLib::StochasticProcess1D;
using QuantLib::StochasticProcess;
using QuantLib::StochasticProcessArray;
using QuantLib::Stock;
using QuantLib::StrikedTypePayoff;
using QuantLib::StrippedOptionletAdapter;
using QuantLib::StrippedOptionletBase;
using QuantLib::StudentDistribution;
using QuantLib::StulzEngine;
using QuantLib::Sunday;
using QuantLib::SuperSharePayoff;
using QuantLib::SvenssonFitting;
using QuantLib::Swap;
using QuantLib::SwapIndex;
using QuantLib::SwapRateHelper;
using QuantLib::SwapSpreadIndex;
using QuantLib::Swaption;
using QuantLib::SwaptionHelper;
using QuantLib::SwaptionVolCube1;
using QuantLib::SwaptionVolCube2;
using QuantLib::SwaptionVolatilityCube;
using QuantLib::SwaptionVolatilityDiscrete;
using QuantLib::SwaptionVolatilityMatrix;
using QuantLib::SwaptionVolatilityStructure;
using QuantLib::SwingExercise;
using QuantLib::TemperatureExponential;
using QuantLib::TermStructure;
using QuantLib::TermStructureConsistentModel;
using QuantLib::Thursday;
using QuantLib::Tian;
using QuantLib::Time;
using QuantLib::TimeBasket;
using QuantLib::TimeGrid;
using QuantLib::TimeSeries;
using QuantLib::TimeUnit;
using QuantLib::TrapezoidIntegral;
using QuantLib::TreeCallableFixedRateBondEngine;
using QuantLib::TreeCapFloorEngine;
using QuantLib::TreeSwaptionEngine;
using QuantLib::TridiagonalOperator;
using QuantLib::Trigeorgis;
using QuantLib::TripleBandLinearOp;
using QuantLib::Tuesday;
using QuantLib::TypePayoff;
using QuantLib::UltimateForwardTermStructure;
using QuantLib::Unadjusted;
using QuantLib::Uniform1dMesher;
using QuantLib::UpRounding;
using QuantLib::UpfrontCdsHelper;
using QuantLib::VanillaForwardPayoff;
using QuantLib::VanillaOption;
using QuantLib::VanillaSwap;
using QuantLib::VanillaSwingOption;
using QuantLib::VannaVolgaBarrierEngine;
using QuantLib::VannaVolgaDoubleBarrierEngine;
using QuantLib::VarianceGammaEngine;
using QuantLib::VarianceGammaProcess;
using QuantLib::Vasicek;
using QuantLib::Volatility;
using QuantLib::VolatilityTermStructure;
using QuantLib::VolatilityType;
using QuantLib::Wednesday;
using QuantLib::Weekday;
using QuantLib::Weekly;
using QuantLib::Weeks;
using QuantLib::WulinYongDoubleBarrierEngine;
using QuantLib::Year;
using QuantLib::YearOnYearInflationSwap;
using QuantLib::YearOnYearInflationSwapHelper;
using QuantLib::Years;
using QuantLib::YieldTermStructure;
using QuantLib::YoYCapFloorTermPriceSurface;
using QuantLib::YoYInflationBachelierCapFloorEngine;
using QuantLib::YoYInflationBlackCapFloorEngine;
using QuantLib::YoYInflationCap;
using QuantLib::YoYInflationCapFloor;
using QuantLib::YoYInflationCapFloorEngine;
using QuantLib::YoYInflationCollar;
using QuantLib::YoYInflationFloor;
using QuantLib::YoYInflationIndex;
using QuantLib::YoYInflationTermStructure;
using QuantLib::YoYInflationUnitDisplacedBlackCapFloorEngine;
using QuantLib::YoYOptionletHelper;
using QuantLib::YoYOptionletStripper;
using QuantLib::YoYOptionletVolatilitySurface;
using QuantLib::ZabrFullFd;
using QuantLib::ZabrInterpolatedSmileSection;
using QuantLib::ZabrLocalVolatility;
using QuantLib::ZabrShortMaturityLognormal;
using QuantLib::ZabrShortMaturityNormal;
using QuantLib::ZabrSmileSection;
using QuantLib::ZeroCouponBond;
using QuantLib::ZeroCouponInflationSwap;
using QuantLib::ZeroCouponInflationSwapHelper;
using QuantLib::ZeroInflationIndex;
using QuantLib::ZeroInflationTermStructure;
using QuantLib::ZeroSpreadedTermStructure;
using QuantLib::ZeroYield;
using QuantLib::bachelierBlackFormula;
using QuantLib::bachelierBlackFormulaAssetItmProbability;
using QuantLib::bachelierBlackFormulaImpliedVol;
using QuantLib::blackFormula;
using QuantLib::blackFormulaAssetItmProbability;
using QuantLib::blackFormulaCashItmProbability;
using QuantLib::blackFormulaImpliedStdDev;
using QuantLib::blackFormulaImpliedStdDevLiRS;
using QuantLib::close;
using QuantLib::close_enough;
using QuantLib::inverse;
using QuantLib::outerProduct;
using QuantLib::pseudoSqrt;
using QuantLib::sabrFlochKennedyVolatility;
using QuantLib::sabrVolatility;
using QuantLib::shiftedSabrVolatility;
using QuantLib::transpose;
%}

// typedef

%{
typedef BoundaryCondition<FdmLinearOp> FdmBoundaryCondition;
typedef Callability::Price CallabilityPrice;
typedef ForwardVanillaEngine<AnalyticEuropeanEngine> ForwardEuropeanEngine;
typedef PiecewiseYieldCurve<SimpleZeroYield, Linear, QuantLib::GlobalBootstrap> GlobalLinearSimpleZeroCurve;
typedef QuantLib::FittedBondDiscountCurve::FittingMethod FittingMethod;
typedef QuantLib::LowDiscrepancy::rsg_type GaussianLowDiscrepancySequenceGenerator;
typedef QuantLib::LowDiscrepancy::ursg_type UniformLowDiscrepancySequenceGenerator;
typedef QuantLib::Matrix::row_iterator MatrixRow;
typedef QuantLib::PseudoRandom::rng_type GaussianRandomGenerator;
typedef QuantLib::PseudoRandom::rsg_type GaussianRandomSequenceGenerator;
typedef QuantLib::PseudoRandom::urng_type UniformRandomGenerator;
typedef QuantLib::PseudoRandom::ursg_type UniformRandomSequenceGenerator;
typedef QuantoEngine<ForwardVanillaOption,AnalyticEuropeanEngine> QuantoForwardEuropeanEngine;
typedef QuantoEngine<VanillaOption,AnalyticEuropeanEngine> QuantoEuropeanEngine;
typedef double doubleOrNull;
typedef int intOrNull;
typedef std::vector<ext::shared_ptr<FdmBoundaryCondition> > FdmBoundaryConditionSet;
%}

%{
using QuantLib::DotProduct;
using QuantLib::Norm2;
using QuantLib::Abs;
using QuantLib::Sqrt;
using QuantLib::Log;
using QuantLib::Exp;
using QuantLib::Pow;
using QuantLib::ContinuousArithmeticAsianVecerEngine;
using QuantLib::LinearFlat;
//using QuantLib::Abcd;
//using QuantLib::SABR;
//using QuantLib::LogCubic;
//using QuantLib::LogMixedLinearCubic;
//using QuantLib::MixedLinearCubic;
using QuantLib::DefaultLogCubic;
using QuantLib::MonotonicLogCubic;
using QuantLib::KrugerLog;
using QuantLib::BackwardflatLinear;
using QuantLib::Bilinear;
using QuantLib::Polynomial;
%}

%{
using QuantLib::AffineModel;
using QuantLib::BatesDetJumpModel;
using QuantLib::BatesDoubleExpModel;
using QuantLib::BatesDoubleExpDetJumpModel;
using QuantLib::VarianceGammaModel;
using QuantLib::EarlyExercise;
using QuantLib::ArithmeticAverageOIS;
using QuantLib::BMASwap;
using QuantLib::IrregularSwap;

using QuantLib::PartialBarrier;
using QuantLib::CliquetOption;
using QuantLib::ComplexChooserOption;
using QuantLib::CompoundOption;
using QuantLib::HolderExtensibleOption;
using QuantLib::PartialTimeBarrierOption;
using QuantLib::SimpleChooserOption;
using QuantLib::VanillaStorageOption;
using QuantLib::WriterExtensibleOption;
using QuantLib::BMAIndex;
%}


#endif
